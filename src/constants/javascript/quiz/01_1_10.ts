import { Quiz } from '@/types/quiz.type';

export const quiz: Quiz = {
  title: 'JavaScript 클래스 마스터하기',
  description:
    '자바스크립트 클래스의 기본 개념부터 고급 활용까지 테스트해보세요',
  categories: [
    {
      title: '클래스 기본 개념',
      description: '클래스의 기본 구조와 특징에 대한 이해를 테스트합니다.',
      questions: [
        {
          id: 1,
          question:
            "자바스크립트에서 클래스가 '문법적 설탕(Syntactic Sugar)'이라고 불리는 이유는 무엇인가요?",
          options: [
            '클래스가 실제로는 존재하지 않는 가짜 문법이기 때문에',
            '프로토타입 기반 상속을 더 쉽게 작성할 수 있게 해주는 문법이기 때문에',
            '다른 언어의 클래스와 완전히 동일한 동작을 하기 때문에',
            '성능 최적화를 위한 특별한 문법이기 때문에',
          ],
          correctAnswer: 1,
          explanation:
            '자바스크립트 클래스는 프로토타입 기반의 상속을 더 직관적이고 쉽게 사용할 수 있도록 제공되는 문법적 기능입니다.',
        },
        {
          id: 2,
          question:
            '다음 중 클래스의 호이스팅(hoisting)에 대한 설명으로 올바른 것은?',
          options: [
            '클래스는 함수처럼 호이스팅되어 선언 전에 사용할 수 있다',
            '클래스는 호이스팅되지 않으므로 선언 전에 사용하면 ReferenceError가 발생한다',
            '클래스는 var처럼 호이스팅되어 undefined로 초기화된다',
            '클래스는 부분적으로만 호이스팅된다',
          ],
          correctAnswer: 1,
          explanation:
            '클래스는 함수 선언과 달리 호이스팅되지 않습니다. 따라서 클래스를 사용하기 전에 반드시 선언해야 합니다.',
        },
        {
          id: 3,
          question: 'private 필드를 선언할 때 사용하는 정확한 문법은?',
          options: [
            'private myField;',
            '_myField;',
            '#myField;',
            'private #myField;',
          ],
          correctAnswer: 2,
          explanation:
            '자바스크립트에서 private 필드는 # 기호를 사용하여 선언합니다.',
        },
        {
          id: 4,
          question:
            '클래스의 정적(static) 멤버에 대한 설명으로 옳지 않은 것은?',
          options: [
            '인스턴스를 생성하지 않고도 접근할 수 있다',
            '모든 인스턴스가 공유하는 기능을 구현할 때 유용하다',
            '인스턴스에서 직접 접근이 가능하다',
            '클래스 자체에 속하는 멤버이다',
          ],
          correctAnswer: 2,
          explanation:
            '정적 멤버는 클래스의 인스턴스가 아닌 클래스 자체에 속하며, 인스턴스에서 직접 접근할 수 없습니다.',
        },
        {
          id: 5,
          question: '다음 중 getter/setter를 사용하는 가장 적절한 경우는?',
          options: [
            '모든 클래스 필드에 대해 무조건 사용할 때',
            '필드값 접근/수정 시 추가적인 로직이나 유효성 검사가 필요할 때',
            'private 필드를 사용하지 않을 때',
            '메서드 이름을 줄이고 싶을 때',
          ],
          correctAnswer: 1,
          explanation:
            'getter/setter는 필드값을 읽거나 수정할 때 추가적인 로직이나 유효성 검사가 필요한 경우에 특히 유용합니다.',
        },
        {
          id: 6,
          question:
            'extends 키워드를 사용한 상속에서 super()를 호출하는 정확한 시점은?',
          options: [
            '자식 클래스 생성자의 어느 위치에서나 호출할 수 있다',
            '자식 클래스 생성자에서 this 키워드를 사용하기 전에 호출해야 한다',
            '자식 클래스 생성자의 마지막에 호출해야 한다',
            'super()는 선택적이므로 호출하지 않아도 된다',
          ],
          correctAnswer: 1,
          explanation:
            '자식 클래스 생성자에서는 this를 사용하기 전에 반드시 super()를 호출해야 합니다.',
        },
        {
          id: 7,
          question: '프로토타입 체인에 대한 설명으로 옳은 것은?',
          options: [
            '클래스 문법을 사용하면 프로토타입 체인이 생성되지 않는다',
            '프로토타입 체인은 성능에 영향을 주지 않는다',
            '프로토타입 체인을 통해 상속된 메서드를 찾아 실행한다',
            '프로토타입 체인은 ES6에서 더 이상 사용되지 않는다',
          ],
          correctAnswer: 2,
          explanation:
            '자바스크립트는 메서드를 호출할 때 프로토타입 체인을 따라 올라가며 해당 메서드를 찾아 실행합니다.',
        },
      ],
    },

    {
      title: '클래스 고급 개념',
      description: '클래스의 심화 개념과 실제 활용에 대한 이해를 테스트합니다.',
      questions: [
        {
          id: 8,
          question: '다음 중 private 필드를 사용해야 하는 가장 적절한 상황은?',
          options: [
            '모든 클래스 필드에 대해 무조건적으로',
            '외부에서 직접 접근하면 안 되는 내부 구현 상태를 캡슐화할 때',
            '메서드 내에서만 사용되는 임시 변수를 저장할 때',
            '다른 클래스에서 상속받아 사용해야 하는 필드의 경우',
          ],
          correctAnswer: 1,
          explanation:
            'private 필드는 클래스의 내부 구현을 캡슐화하고 외부로부터 보호해야 할 때 사용하는 것이 가장 적절합니다.',
        },
        {
          id: 9,
          question:
            '정적 초기화 블록(static initialization block)의 주요 용도는?',
          options: [
            '인스턴스 생성 시 초기화 로직을 수행하기 위해',
            '복잡한 정적 필드 초기화 로직을 수행하기 위해',
            'private 필드를 초기화하기 위해',
            '생성자를 대체하기 위해',
          ],
          correctAnswer: 1,
          explanation:
            '정적 초기화 블록은 복잡한 정적 필드의 초기화 로직이 필요할 때 사용됩니다.',
        },
        {
          id: 10,
          question: '클래스의 메서드가 프로토타입에 정의되는 것의 장점은?',
          options: [
            '메모리 사용량이 증가한다',
            '각 인스턴스마다 메서드의 복사본이 생성된다',
            '모든 인스턴스가 같은 메서드를 공유하여 메모리가 절약된다',
            '메서드 호출 속도가 더 빨라진다',
          ],
          correctAnswer: 2,
          explanation:
            '프로토타입에 정의된 메서드는 모든 인스턴스가 공유하므로 메모리 사용량이 효율적입니다.',
        },
        {
          id: 11,
          question: '클래스에서 Symbol.species를 사용하는 주된 목적은?',
          options: [
            '클래스의 이름을 변경하기 위해',
            '파생 객체를 생성할 때 사용할 생성자를 지정하기 위해',
            '클래스의 private 필드를 정의하기 위해',
            '클래스의 상속을 방지하기 위해',
          ],
          correctAnswer: 1,
          explanation:
            'Symbol.species는 파생 객체를 생성할 때 사용할 생성자를 지정하는 데 사용됩니다.',
        },
        {
          id: 12,
          question: '다음 중 클래스의 this 바인딩에 대한 설명으로 올바른 것은?',
          options: [
            '화살표 함수는 자신만의 this를 가진다',
            '일반 메서드는 항상 클래스 인스턴스를 this로 가진다',
            '정적 메서드의 this는 항상 undefined이다',
            '메서드가 콜백으로 전달될 때 this는 자동으로 바인딩된다',
          ],
          correctAnswer: 0,
          explanation:
            '일반 메서드는 호출 방식에 따라 this가 달라질 수 있으며, 화살표 함수는 자신이 선언된 컨텍스트의 this를 유지합니다.',
        },
        {
          id: 13,
          question: '클래스의 필드 선언과 관련하여 가장 올바른 설명은?',
          options: [
            '필드는 반드시 constructor 내에서 선언해야 한다',
            'public 필드는 클래스 선언부에서 직접 선언할 수 있다',
            'private 필드는 반드시 메서드 내에서 선언해야 한다',
            '정적 필드는 클래스 외부에서 선언해야 한다',
          ],
          correctAnswer: 1,
          explanation:
            'public 필드는 클래스 선언부에서 직접 선언할 수 있으며, 이는 더 명확한 코드 구조를 제공합니다.',
        },
        {
          id: 14,
          question:
            '다음 중 클래스 상속 시 주의해야 할 점으로 가장 적절한 것은?',
          options: [
            '상속은 최대한 많이 사용하는 것이 좋다',
            '상속 대신 항상 컴포지션을 사용해야 한다',
            '깊은 상속 계층은 코드의 유지보수성을 떨어뜨릴 수 있다',
            '상속은 ES6에서만 지원된다',
          ],
          correctAnswer: 2,
          explanation:
            '깊은 상속 계층은 코드의 복잡성을 증가시키고 유지보수를 어렵게 만들 수 있으므로 주의해야 합니다.',
        },
        {
          id: 15,
          question:
            '클래스의 접근자 프로퍼티(getter/setter)와 관련된 최적화 문제는?',
          options: [
            'getter/setter는 항상 더 나은 성능을 제공한다',
            '접근자 프로퍼티는 일반 프로퍼티보다 접근 속도가 더 느릴 수 있다',
            'getter는 성능에 영향을 주지 않는다',
            'setter는 자동으로 성능을 최적화한다',
          ],
          correctAnswer: 1,
          explanation:
            '접근자 프로퍼티는 함수 호출을 동반하므로 일반 프로퍼티에 비해 접근 속도가 더 느릴 수 있습니다.',
        },
      ],
    },

    {
      title: '클래스 실전 활용',
      description:
        '실제 개발 상황에서의 클래스 활용과 패턴에 대한 이해를 테스트합니다.',
      questions: [
        {
          id: 16,
          question:
            '다음 중 Map 객체와 일반 객체의 차이점으로 올바르지 않은 것은?',
          options: [
            'Map은 key로 어떤 값이든 사용할 수 있다',
            'Map은 순서를 보장한다',
            'Map은 크기를 쉽게 알 수 있다',
            'Map은 프로토타입 체인을 사용하지 않는다',
          ],
          correctAnswer: 3,
          explanation:
            'Map도 내부적으로 프로토타입 체인을 사용합니다. 다만 Map의 key-value 저장 방식은 프로토타입 체인과 무관합니다.',
        },
        {
          id: 17,
          question: 'Date 객체 사용 시 주의해야 할 점으로 가장 적절한 것은?',
          options: [
            'Date 객체는 불변(immutable)객체이다',
            '월(month)은 0부터 시작한다',
            '시간대 처리가 항상 정확하다',
            '날짜 계산이 항상 직관적이다',
          ],
          correctAnswer: 1,
          explanation:
            'JavaScript의 Date 객체에서 월은 0부터 시작하므로(0-11), 이를 주의하여 사용해야 합니다.',
        },
        {
          id: 18,
          question: 'Error 클래스를 상속받아 커스텀 에러를 만들 때의 장점은?',
          options: [
            '성능이 더 좋아진다',
            '에러 스택 추적이 불가능해진다',
            '타입 체크와 에러 처리가 더 명확해진다',
            '무조건 프로그램이 종료된다',
          ],
          correctAnswer: 2,
          explanation:
            '커스텀 에러 클래스를 사용하면 instanceof를 통한 타입 체크가 가능하고, 특정 에러 상황에 대한 처리를 더 명확하게 할 수 있습니다.',
        },
        {
          id: 19,
          question:
            '단일 책임 원칙(Single Responsibility Principle)을 클래스에 적용할 때 가장 적절한 방법은?',
          options: [
            '가능한 한 많은 기능을 하나의 클래스에 넣는다',
            '모든 메서드를 정적 메서드로 만든다',
            '하나의 클래스가 하나의 책임만 가지도록 설계한다',
            '상속을 최대한 많이 사용한다',
          ],
          correctAnswer: 2,
          explanation:
            '단일 책임 원칙에 따르면, 클래스는 하나의 책임만 가져야 하며 변경의 이유도 하나여야 합니다.',
        },
        {
          id: 20,
          question:
            '가변성(Mutability)과 관련하여 클래스 설계 시 고려해야 할 가장 중요한 점은?',
          options: [
            '모든 객체는 가변적이어야 한다',
            '가변 상태는 예측 가능하고 안전하게 관리되어야 한다',
            '불변 객체는 사용하지 않아야 한다',
            '모든 필드는 public이어야 한다',
          ],
          correctAnswer: 1,
          explanation:
            '가변 상태는 프로그램의 복잡성을 증가시킬 수 있으므로, 상태 변경을 예측 가능하고 안전하게 관리하는 것이 중요합니다.',
        },
        {
          id: 21,
          question:
            '자바스크립트의 프로토타입 체인과 클래스 상속의 관계를 가장 잘 설명한 것은?',
          options: [
            '클래스 상속은 프로토타입 체인과 전혀 관계가 없다',
            '클래스 상속은 내부적으로 프로토타입 체인을 통해 구현된다',
            '프로토타입 체인은 ES6에서 제거되었다',
            '클래스 상속은 프로토타입 체인을 대체한다',
          ],
          correctAnswer: 1,
          explanation:
            '자바스크립트의 클래스 상속은 내부적으로 프로토타입 체인을 통해 구현됩니다. 클래스는 프로토타입 기반 상속을 더 쉽게 사용할 수 있게 해주는 문법입니다.',
        },
        {
          id: 22,
          question: '다음 중 클래스를 사용하지 않는 것이 더 좋은 경우는?',
          options: [
            '복잡한 상태와 동작을 관리해야 할 때',
            '단순한 데이터 구조만 필요할 때',
            '상속이 필요한 객체를 만들 때',
            '캡슐화가 필요한 경우',
          ],
          correctAnswer: 1,
          explanation:
            '단순한 데이터 구조만 필요한 경우에는 객체 리터럴이나 다른 간단한 데이터 구조를 사용하는 것이 더 적절할 수 있습니다.',
        },
      ],
    },
  ],
};
